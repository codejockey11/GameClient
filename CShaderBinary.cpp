#include "CShaderBinary.h"

/*
*/
CShaderBinary::CShaderBinary()
{
	memset(this, 0x00, sizeof(CShaderBinary));
}

/*
*/
CShaderBinary::CShaderBinary(CErrorLog* errorLog, CLocal* local, const char* name, const char* entryPoint, const char* version, int shaderModel)
{
	memset(this, 0x00, sizeof(CShaderBinary));

	m_errorLog = errorLog;

	m_local = local;

	m_name = new CString(name);

	m_entryPoint = new CString(entryPoint);

	m_version = new CString(version);

#ifdef _DEBUG
	m_flags |= D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;
#endif

	m_filename = new CString(m_local->m_shaderInstallPath->m_text);

	m_filename->Append(m_name->m_text);

	if (shaderModel == D3D_SHADER_MODEL::D3D_SHADER_MODEL_5_1)
	{
		m_hr = D3DCompileFromFile(m_filename->GetWide(), nullptr, D3D_COMPILE_STANDARD_FILE_INCLUDE, m_entryPoint->m_text, m_version->m_text, m_flags, 0, &m_shader, &m_errors);

		if (m_hr != S_OK)
		{
			m_errorLog->WriteComErrorMessage(true, "CShaderBinary::CShaderBinary::D3DCompileFromFile:", m_hr);

			if (m_errors)
			{
				m_errorLog->WriteError(true, "CShaderBinary::CShaderBinary::Compile Errors\n%s", (char*)m_errors->GetBufferPointer());
			}

			m_shader = nullptr;
		}

		if (m_errors)
		{
			m_errors->Release();
			
			m_errors = nullptr;
		}

		m_isInitialized = true;

		return;
	}

	DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&m_utils));
	
	DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&m_compiler));
	
	m_utils->CreateDefaultIncludeHandler(&m_includeHandler);

	LPCWSTR pszArgs[] =
	{
		//L"myshader.txt",				// Optional shader source file name for error reporting and for PIX shader source view.  
		L"-E", m_entryPoint->GetWide(),	// Entry point.
		L"-T", m_version->GetWide(),	// Target.
		L"-Zs",							// Enable debug information (slim format)
		L"-I", m_local->m_shaderInstallPath->GetWide(), // include path to 'shader' directory
		//L"-D", L"MYDEFINE=1",			// A single define.
		L"-Fo", L"myshader.bin",		// Optional. Stored in the pdb. 
		L"-Fd", L"myshader.pdb",		// The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
		L"-Qstrip_reflect"				// Strip reflection into a separate blob. 
	};

	m_utils->LoadFile(m_filename->GetWide(), nullptr, &m_source);

	m_sourceBuffer.Ptr = m_source->GetBufferPointer();
	m_sourceBuffer.Size = m_source->GetBufferSize();
	m_sourceBuffer.Encoding = DXC_CP_ACP;

	m_compiler->Compile(
		&m_sourceBuffer,
		pszArgs,
		_countof(pszArgs),
		m_includeHandler,
		IID_PPV_ARGS(&m_results)
	);

	m_results->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&m_utfErrors), nullptr);

	if ((m_utfErrors) && (m_utfErrors->GetStringLength() > 0))
	{
		m_errorLog->WriteError(true, "CShaderBinary::CShaderBinary:Compile Errors\n%s", m_utfErrors->GetStringPointer());

		m_shader = nullptr;

		m_includeHandler.Release();
		m_utils.Release();
		m_compiler.Release();
		m_source.Release();
		m_results.Release();
		m_utfErrors.Release();
		m_shaderName.Release();

		return;
	}

	m_results->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&m_shader), &m_shaderName);

	m_includeHandler.Release();
	m_utils.Release();
	m_compiler.Release();
	m_source.Release();
	m_results.Release();
	m_utfErrors.Release();
	m_shaderName.Release();

	m_isInitialized = true;
}

/*
*/
CShaderBinary::~CShaderBinary()
{
	delete m_version;
	delete m_entryPoint;
	delete m_filename;
	delete m_name;

	if (m_shader)
	{
		m_shader->Release();
		
		m_shader = nullptr;
	}
}